package org.ecocean;

import java.io.FileNotFoundException;
import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;

import org.json.JSONArray;
import org.json.JSONObject;

import org.ecocean.identity.IBEISIA;
import org.ecocean.media.MediaAsset;

public class IAJsonProperties extends JsonProperties {

	// maps IA.properties keys to IA.json keys that should return the same value
	private static final Map<String, String> globalBackCompatibleKeyMap;
	static {
		Map<String,String> m = new HashMap<String,String>();
		m.put("IBEISIARestUrlAddImages", "_global.add_images");
		m.put("IBEISIARestUrlAddAnnotations", "_global.add_annotations");
		m.put("IBEISIARestUrlStartIdentifyAnnotations", "_global.start_identify");
		m.put("IBEISIARestUrlStartDetectImages", "_global.start_detect");
		m.put("IBEISIARestUrlDetectReview", "_global.detect_review");
		m.put("IBEISIARestUrlGetJobStatus", "_global.get_job_status");
		m.put("IBEISIARestUrlGetJobResult", "_global.get_job_result");
		globalBackCompatibleKeyMap = Collections.unmodifiableMap(m);
	}

	public static final String DETECT_URL_KEY = "start_detect";

	public IAJsonProperties() throws FileNotFoundException {
		super("IA.json");
	}

	// hackey constructor so we don't need to catch an exception every time we use these. Is there a better way?
	public static IAJsonProperties iaConfig() {
		try {
			return new IAJsonProperties();
		} catch (Exception e) {
			System.out.println("IAJsonProperties ERROR: Could not find IA.json file! returning null and therefore about to hit an NPE elsewhere");
			return null;
		}
	}

	// naming convention: not using 'get' on static methods
	public static String taxonomyKey(Taxonomy taxy) {
		return taxy.getScientificName().replace(' ', '.');
	}

	// Detection methods
	public static String detectionKey(Taxonomy taxy) {
		return taxonomyKey(taxy) + "._detect_conf";
	}

	public JSONArray getDetectionConfigs(Taxonomy taxy) {
		return (JSONArray) this.get(detectionKey(taxy));
	}

	public JSONArray getDetectionConfigs(MediaAsset ma, Shepherd myShepherd) {
		JSONArray allConfs = new JSONArray();
		for (Taxonomy taxy: ma.getTaxonomies(myShepherd)) {
			JSONArray theseConfs = getDetectionConfigs(taxy);
			for (int i=0; i<theseConfs.length(); i++) {
				allConfs.put(theseConfs.get(i));
			}
		}
		return allConfs;
	}

	public int numDetectionAlgos(Taxonomy taxy) {
		JSONArray detectConfs = getDetectionConfigs(taxy);
		return detectConfs.length();
	}

	public JSONObject getDetectionConfig(Taxonomy taxy) {
		return getDetectionConfig(taxy, 0);
	}
	// all detection methods take an int i, bc there may be multiple detection algos for a taxonomy
	// DetectionArgs are what we pass to IA. DetectionConfig is all of those, plus the target url, minus the callback (which is generated by each wildbook vis a vis its baseUrl, and not a config value)
	public JSONObject getDetectionConfig(Taxonomy taxy, int i) {
		JSONArray confs = getDetectionConfigs(taxy);
		System.out.println("IAJsonProperties.getDetectionConfigs returned "+confs.toString());
		return confs.getJSONObject(i);
	}

	// DetectionArgs are what we pass to IA.
	public JSONObject getDetectionArgs(Taxonomy taxy, String baseUrl) {
		return getDetectionArgs(taxy, baseUrl, 0);
	}
	public JSONObject getDetectionArgs(Taxonomy taxy, String baseUrl, int i) {
		JSONObject config = getDetectionConfig(taxy, i);
		// we can't just mess with config bc changes aren't scoped to this method
		// and this is the stupid-ass way to clone JSONObjects
		JSONObject args = new JSONObject(config, JSONObject.getNames(config));
		args.remove(DETECT_URL_KEY);
		String callbackUrl = IBEISIA.callbackUrl(baseUrl);
		args.put("callback_url", callbackUrl);
		return args;
	}

	public String getDetectionUrl(Taxonomy taxy) {
		return getDetectionUrl(taxy, 0);
	}
	public String getDetectionUrl(Taxonomy taxy, int i) {
		JSONObject conf = getDetectionConfig(taxy, i);
		System.out.println("getDetectionUrl looking for "+DETECT_URL_KEY+" in conf "+conf.toString());
		return conf.getString(DETECT_URL_KEY);
	}

	// e.g. if a humpback whale detection returns ia class sperm_whale_fluke this will return humpback_fluke or whatever
	public String convertIAClassForTaxonomy(String returnedIAClass, Taxonomy taxy) {
		String detKey = detectionKey(taxy);
		String lookupKey = detKey + "." + "_save_as";
		return (String) get(lookupKey);
	}

	// Identification methods
	public static String identKey(Taxonomy taxy) {
		return identKey(taxy, "_default");
	}
	public static String identKey(Taxonomy taxy, String iaClass) {
		return taxonomyKey(taxy) + "." + iaClass;
	}
	public static String identConfigKey(Taxonomy taxy) {
		return identConfigKey(taxy, "_default");
	}
	public static String identConfigKey(Taxonomy taxy, String iaClass) {
		return identKey(taxy, iaClass)+"._id_conf";
	}

	public JSONArray getIdentConfig(Taxonomy taxy) {
		return getIdentConfig(taxy, "_default");
	}

	public JSONArray getIdentConfig(Taxonomy taxy, String iaClass) {
		JSONArray config = (JSONArray) this.get(identConfigKey(taxy, iaClass));
		if (config==null) {
			System.out.println("IAJsonProperties: could not find ident config for taxonomy "
				+taxy.toString()+" and iaClass "+iaClass+". Trying _default iaClass instead.");
			config = (JSONArray) this.get(identConfigKey(taxy, "_default"));
		}
		if (config==null) System.out.println("IAJsonProperties WARNING: could not find any identConfig for taxonomy "+taxy+". Returning null.");
		return config;
	}

	// mimics an old IBEISIA method for easy migration
	// note the key discrepancy between queryConfigDict and query_config_dict in old world vs new
  public List<JSONObject> identOpts(Shepherd myShepherd, Annotation ann) {
  	Taxonomy taxy = ann.getTaxonomy(myShepherd);
  	String iaClass = ann.getIAClass();
  	JSONArray identConfig = getIdentConfig(taxy, iaClass);
  	if (identConfig==null) return null;

  	List<JSONObject> identOpts = new ArrayList<JSONObject>();
  	for (int i=0; i<identConfig.length(); i++) {
  		JSONObject thisIdentOpt = copyJobj(identConfig.getJSONObject(i));
  		// so we don't break lookups for queryConfigDict downstream (old world)
  		thisIdentOpt.put("queryConfigDict", thisIdentOpt.get("query_config_dict"));
  		identOpts.add(thisIdentOpt);
  	}
  	return identOpts;
  }

	public static final Map<String, String> getGlobalBackCompatibleKeyMap() {
	    return globalBackCompatibleKeyMap;
	}

	public static JSONObject copyJobj(JSONObject jobj) {
		return new JSONObject(jobj, JSONObject.getNames(jobj));
	}

}

